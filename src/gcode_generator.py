import math
from typing import List
from dataclasses import dataclass
from .file_parser import ParsedInstructions, DrillPoint, CircularCut, HexagonalCut, OutlinePoint

@dataclass
class DrillParameters:
    drill_diameter: float
    material_depth: float
    feed_rate: float
    spindle_speed: int
    safe_height: float
    plunge_rate: float

@dataclass
class CutParameters:
    mill_diameter: float
    material_depth: float
    path_depth: float
    feed_rate: float
    spindle_speed: int
    safe_height: float
    plunge_rate: float

@dataclass
class MachiningParameters:
    drill_params: DrillParameters
    cut_params: CutParameters

class GCodeGenerator:
    def __init__(self, params: MachiningParameters):
        self.params = params
    
    def generate_drill_gcode(self, instructions: ParsedInstructions) -> str:
        """Generate G-code for drilling operations only."""
        if not instructions.drill_holes:
            return ""
        
        gcode_lines = []
        drill_params = self.params.drill_params
        
        gcode_lines.extend(self._get_header(drill_params, "DRILLING OPERATIONS"))
        gcode_lines.extend(self._get_drill_operations(instructions.drill_holes, drill_params))
        gcode_lines.extend(self._get_footer())
        
        return '\n'.join(gcode_lines)
    
    def generate_cut_gcode(self, instructions: ParsedInstructions) -> str:
        """Generate G-code for cutting operations only."""
        has_cuts = (instructions.circular_cuts or 
                   instructions.hexagonal_cuts or 
                   instructions.outline_points)
        
        if not has_cuts:
            return ""
        
        gcode_lines = []
        cut_params = self.params.cut_params
        
        gcode_lines.extend(self._get_header(cut_params, "CUTTING OPERATIONS"))
        
        if instructions.circular_cuts:
            gcode_lines.extend(self._get_circular_cuts(instructions.circular_cuts, cut_params))
        
        if instructions.hexagonal_cuts:
            gcode_lines.extend(self._get_hexagonal_cuts(instructions.hexagonal_cuts, cut_params))
        
        if instructions.outline_points:
            gcode_lines.extend(self._get_outline_cut(instructions.outline_points, cut_params))
        
        gcode_lines.extend(self._get_footer())
        
        return '\n'.join(gcode_lines)
    
    def _get_header(self, params, operation_type):
        """Get G-code header with initialization commands."""
        return [
            f"; G-code generated for OMIO CNC - {operation_type}",
            "; Generated by FIRST Robotics G-code Generator",
            "",
            "G21 ; Set units to millimeters",
            "G90 ; Absolute positioning",
            "G17 ; XY plane selection",
            f"M3 S{params.spindle_speed} ; Start spindle",
            "G4 P2 ; Wait 2 seconds for spindle to reach speed",
            f"G0 Z{params.safe_height} ; Move to safe height",
            ""
        ]
    
    def _get_drill_operations(self, drill_points: List[DrillPoint], params: DrillParameters):
        """Generate G-code for drilling operations."""
        lines = [
            "; === DRILLING OPERATIONS ===",
            f"; Drill diameter: {params.drill_diameter} inches",
            ""
        ]
        
        for i, point in enumerate(drill_points):
            x_mm = point.x * 25.4  # Convert inches to mm
            y_mm = point.y * 25.4
            
            lines.extend([
                f"; Drill hole {i+1} at ({point.x}, {point.y}) inches",
                f"G0 X{x_mm:.3f} Y{y_mm:.3f} ; Position over hole",
                f"G0 Z0.5 ; Move to approach height",
                f"G1 Z-{params.material_depth * 25.4:.3f} F{params.plunge_rate} ; Drill to depth",
                f"G0 Z{params.safe_height} ; Retract to safe height",
                ""
            ])
        
        return lines
    
    def _get_circular_cuts(self, circular_cuts: List[CircularCut], params: CutParameters):
        """Generate G-code for circular cuts."""
        lines = [
            "; === CIRCULAR CUTS ===",
            ""
        ]
        
        for i, cut in enumerate(circular_cuts):
            x_mm = cut.x * 25.4
            y_mm = cut.y * 25.4
            radius_mm = (cut.diameter / 2) * 25.4
            
            # Start at the edge of the circle
            start_x = x_mm + radius_mm - (params.mill_diameter * 25.4 / 2)
            
            # Calculate number of passes needed
            total_depth_mm = params.material_depth * 25.4
            path_depth_mm = params.path_depth * 25.4
            num_passes = math.ceil(total_depth_mm / path_depth_mm)
            
            lines.extend([
                f"; Circular cut {i+1}: diameter {cut.diameter} at ({cut.x}, {cut.y}) inches",
                f"; Total depth: {params.material_depth} inches, Path depth: {params.path_depth} inches, Passes: {num_passes}",
                f"G0 X{start_x:.3f} Y{y_mm:.3f} ; Position at circle edge",
                f"G0 Z0.5 ; Move to approach height"
            ])
            
            # Multiple passes
            for pass_num in range(num_passes):
                current_depth = min((pass_num + 1) * path_depth_mm, total_depth_mm)
                lines.extend([
                    f"; Pass {pass_num + 1}/{num_passes} to depth {current_depth:.3f}mm",
                    f"G1 Z-{current_depth:.3f} F{params.plunge_rate} ; Plunge to pass depth",
                    f"G2 X{start_x:.3f} Y{y_mm:.3f} I{-radius_mm + (params.mill_diameter * 25.4 / 2):.3f} J0 F{params.feed_rate} ; Cut circle"
                ])
            
            lines.extend([
                f"G0 Z{params.safe_height} ; Retract to safe height",
                ""
            ])
        
        return lines
    
    def _get_hexagonal_cuts(self, hex_cuts: List[HexagonalCut], params: CutParameters):
        """Generate G-code for hexagonal cuts."""
        lines = [
            "; === HEXAGONAL CUTS ===",
            ""
        ]
        
        for i, cut in enumerate(hex_cuts):
            center_x_mm = cut.x * 25.4
            center_y_mm = cut.y * 25.4
            radius_mm = (cut.diameter / 2) * 25.4
            
            # Calculate hexagon vertices
            vertices = []
            for j in range(7):  # 7 points to close the hexagon
                angle = j * math.pi / 3
                x = center_x_mm + radius_mm * math.cos(angle)
                y = center_y_mm + radius_mm * math.sin(angle)
                vertices.append((x, y))
            
            # Calculate number of passes needed
            total_depth_mm = params.material_depth * 25.4
            path_depth_mm = params.path_depth * 25.4
            num_passes = math.ceil(total_depth_mm / path_depth_mm)
            
            lines.extend([
                f"; Hexagonal cut {i+1}: diameter {cut.diameter} at ({cut.x}, {cut.y}) inches",
                f"; Total depth: {params.material_depth} inches, Path depth: {params.path_depth} inches, Passes: {num_passes}",
                f"G0 X{vertices[0][0]:.3f} Y{vertices[0][1]:.3f} ; Position at first vertex",
                f"G0 Z0.5 ; Move to approach height"
            ])
            
            # Multiple passes
            for pass_num in range(num_passes):
                current_depth = min((pass_num + 1) * path_depth_mm, total_depth_mm)
                lines.append(f"; Pass {pass_num + 1}/{num_passes} to depth {current_depth:.3f}mm")
                lines.append(f"G1 Z-{current_depth:.3f} F{params.plunge_rate} ; Plunge to pass depth")
                
                for j in range(1, len(vertices)):
                    lines.append(f"G1 X{vertices[j][0]:.3f} Y{vertices[j][1]:.3f} F{params.feed_rate} ; Cut to vertex {j+1}")
            
            lines.extend([
                f"G0 Z{params.safe_height} ; Retract to safe height",
                ""
            ])
        
        return lines
    
    def _get_outline_cut(self, outline_points: List[OutlinePoint], params: CutParameters):
        """Generate G-code for outline cutting."""
        if len(outline_points) < 2:
            return []
        
        lines = [
            "; === OUTLINE CUT ===",
            ""
        ]
        
        # Calculate number of passes needed
        total_depth_mm = params.material_depth * 25.4
        path_depth_mm = params.path_depth * 25.4
        num_passes = math.ceil(total_depth_mm / path_depth_mm)
        
        # Move to first point
        first_point = outline_points[0]
        x_mm = first_point.x * 25.4
        y_mm = first_point.y * 25.4
        
        lines.extend([
            f"; Total depth: {params.material_depth} inches, Path depth: {params.path_depth} inches, Passes: {num_passes}",
            f"G0 X{x_mm:.3f} Y{y_mm:.3f} ; Position at outline start",
            f"G0 Z0.5 ; Move to approach height"
        ])
        
        # Multiple passes
        for pass_num in range(num_passes):
            current_depth = min((pass_num + 1) * path_depth_mm, total_depth_mm)
            lines.append(f"; Pass {pass_num + 1}/{num_passes} to depth {current_depth:.3f}mm")
            lines.append(f"G1 Z-{current_depth:.3f} F{params.plunge_rate} ; Plunge to pass depth")
            
            # Cut along outline
            for point in outline_points[1:]:
                x_mm = point.x * 25.4
                y_mm = point.y * 25.4
                lines.append(f"G1 X{x_mm:.3f} Y{y_mm:.3f} F{params.feed_rate} ; Cut to ({point.x}, {point.y})")
        
        lines.extend([
            f"G0 Z{params.safe_height} ; Retract to safe height",
            ""
        ])
        
        return lines
    
    def _get_footer(self):
        """Get G-code footer with cleanup commands."""
        return [
            "; === PROGRAM END ===",
            "M5 ; Stop spindle",
            "G0 Z25 ; Move to safe height",
            "G0 X0 Y0 ; Return to origin",
            "M30 ; Program end and rewind"
        ]